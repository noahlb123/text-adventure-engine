<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Text Adventure Engine</title>
    <link rel="stylesheet" href="style.css">
    <script src="background.js"></script>
</head>
<body>
    <canvas id="canvas" style="display: block;"></canvas>
    <div id="in-front-canvas">
        <input type="file" id="upload" name="upload" accept=".txt" />
        <div id="main">
            <p>Input a .txt text adventure file to begin.</p>
            <div id="options"></div>
        </div>
    </div>
<script>
//setup background
B = new Background(document.getElementById('canvas'));
function anim() {
    B.draw();
    requestAnimationFrame(anim);
}
anim();

class TextEngine {
    constructor(text, pElm, oElm) {
        this.text = text;
        this.pElm = pElm;
        this.oElm = oElm;
        this.option_map = {};
        this.scene_map = {};
    }

    new(text) {
        this.parse(text);
        this.load(this.scene_map[Object.keys(this.scene_map)[0]]);
        console.log(this.scene_map);
    }

    parse(text=this.text) {
        this.text = text;
        this.option_map = {};
        this.scene_map = {};
        var scenes = text.trim().slice(text.indexOf('#'), text.length).split('#');
        scenes.forEach(scene => {
            console.log(scene);
            if(!scene) {return;}
            let name = scene.slice(0, scene.indexOf('\n')).trim().toLowerCase();
            let body = scene.slice(scene.indexOf('/') + 1, scene.lastIndexOf('/')).trim();
            let options = scene.indexOf('-') != -1 ? scene.slice(scene.indexOf('-') + 1, Math.max(scene.length, scene.lastIndexOf('-') + scene.slice(scene.lastIndexOf('-'), -1).indexOf('\n'))).split('-'): [];
            for(let i = 0; i < options.length; i++) {
                let option = options[i];
                let key, value;
                [key, value] = option.split(':');
                this.option_map[name + '#' + key.trim()] = value.trim().toLowerCase();
                options[i] = [key.trim(), value.trim().toLowerCase()];
            }
            this.scene_map[name] = {'body': body, 'options': options};
        });
    }

    choose(scene_name, option_name) {
        return this.scene_map[this.option_map[scene_name + '#' + option_name]];
    }

    load(scene_obj) {
        this.pElm.innerHTML = '';
        this.oElm.innerHTML = '';
        this.pElm.appendChild(this.oElm);
        scene_obj.body.split('\n').forEach(textLine => {
            let p = document.createElement("p");
            p.innerHTML = textLine == '' ? '\n': textLine;
            this.pElm.insertBefore(p, this.oElm);
        });
        scene_obj.options.forEach(pair => {
            let p = document.createElement("p");
            p.innerHTML = pair[0];
            p.onclick = () => this.load(this.scene_map[pair[1]]);
            this.oElm.appendChild(p);
        });
    }
}

TE = new TextEngine('', document.getElementById('main'), document.getElementById('options'));

//read input files
inputElm = document.getElementById('upload');
inputElm.addEventListener('change', () => {
    const file = inputElm.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.readAsText(file, 'UTF-8');
    reader.onload = function({ target }) {
        TE.new(target.result);
    }
    reader.onerror = function() {
        console.log('error reading file');
    }
});
</script>
</body>
</html>